import { Source } from "tstl/container/Source";
import { Entry } from "tstl/utility/Entry";

import { ICollection } from "../basic/ICollection";
import { CollectionEvent } from "../basic/CollectionEvent";
import { EventDispatcher } from "../basic/EventDispatcher";

import "./internal";

export class SourceCollection<Key, T> 
	extends Source<Key, T>
	implements ICollection<Entry<Key, T>, 
		Source<Key, T>, 
		Source.Iterator<Key, T>, 
		Source.ReverseIterator<Key, T>>
{
	/**
	 * @hidden
	 */
	private dispatcher_: EventDispatcher<Entry<Key, T>, 
		Source<Key, T>, 
		Source.Iterator<Key, T>, 
		Source.ReverseIterator<Key, T>> = new EventDispatcher();

	/* ---------------------------------------------------------
		CONSTRUCTORS
	--------------------------------------------------------- */
	// using super.constructor;

	public clear(): void
	{
		let first = this.begin();
		let last = this.end();

		super.clear();
		this.dispatchEvent(new CollectionEvent("erase", first, last));
	}

	/* ---------------------------------------------------------
		ELEMENTS I/O
	--------------------------------------------------------- */
	/**
	 * @hidden
	 */
	protected _Handle_insert(first: Source.Iterator<Key, T>, last: Source.Iterator<Key, T>): void
	{
		super._Handle_insert(first, last);
		
		this.dispatchEvent(new CollectionEvent("insert", first, last));
	}

	/**
	 * @hidden
	 */
	protected _Handle_erase(first: Source.Iterator<Key, T>, last: Source.Iterator<Key, T>): void
	{
		this._Handle_erase(first, last);
		
		this.dispatchEvent(new CollectionEvent("erase", first, last));
	}

	/* =========================================================
		EVENT DISPATCHER
			- NOTIFIERS
			- ACCESSORS
	============================================================
		NOTIFIERS
	--------------------------------------------------------- */
	/**
	 * @inheritDoc
	 */
	public dispatchEvent(event: SourceCollection.Event<Key, T>): void
	{
		if (this.dispatcher_)
			this.dispatcher_.dispatchEvent(event);
	}

	/**
	 * @inheritDoc
	 */
	public refresh(): void;

	/**
	 * @inheritDoc
	 */
	public refresh(it: Source.Iterator<Key, T>): void;

	/**
	 * @inheritDoc
	 */
	public refresh(first: Source.Iterator<Key, T>, last: Source.Iterator<Key, T>): void;

	public refresh(first: Source.Iterator<Key, T> = null, last: Source.Iterator<Key, T> = null): void
	{
		if (first === null)
		{
			first = this.begin();
			last = this.end();
		}
		else if (last === null)
			last = first.next();

		this.dispatchEvent(new CollectionEvent("refresh", first, last));
	}

	/* ---------------------------------------------------------
		ACCESSORS
	-------------------------------------------------------- */
	/**
	 * @inheritDoc
	 */
	public hasEventListener(type: CollectionEvent.Type): boolean
	{
		return this.dispatcher_.hasEventListener(type);
	}

	/**
	 * @inheritDoc
	 */
	public addEventListener(type: CollectionEvent.Type, listener: SourceCollection.Listener<Key, T>): void
	{
		this.dispatcher_.addEventListener(type, listener);
	}

	/**
	 * @inheritDoc
	 */
	public removeEventListener(type: CollectionEvent.Type, listener: SourceCollection.Listener<Key, T>): void
	{
		this.dispatcher_.removeEventListener(type, listener);
	}
}

export namespace SourceCollection
{
	export type Event<Key, T> = CollectionEvent<Entry<Key, T>, 
		Source<Key, T>, 
		Source.Iterator<Key, T>, 
		Source.ReverseIterator<Key, T>>;

	export type Listener<Key, T> = CollectionEvent.Listener<Entry<Key, T>, 
		Source<Key, T>, 
		Source.Iterator<Key, T>, 
		Source.ReverseIterator<Key, T>>;

	export const Event = CollectionEvent;
	export import Iterator = Source.Iterator;
	export import ReverseIterator = Source.ReverseIterator;
}

const old_swap = Source.prototype.swap;
Source.prototype.swap = function <Key, T>(obj: Source<Key, T>): void
{
	old_swap.call(this, obj);

	if (this instanceof SourceCollection)
		this.refresh();
	if (obj instanceof SourceCollection)
		obj.refresh();
};